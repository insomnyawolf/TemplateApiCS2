using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CustomSourceGenerator
{
    /// <summary>
    /// https://github.com/dotnet/roslyn/blob/main/docs/features/incremental-generators.md
    /// </summary>
    [Generator(LanguageNames.CSharp)]
    public class BaseModelSourceGenerator : IIncrementalGenerator
    {
        public const string NameSpace = "webapi.Database.Models";
        public const string BaseModelNamespace = "webapi.Database";
        public const string GeneratorName = "BaseModelSourceGenerator";

        public void Initialize(IncrementalGeneratorInitializationContext initContext)
        {
            //if (!Debugger.IsAttached)
            //{
            //    Debugger.Launch();
            //}

            initContext.RegisterPostInitializationOutput(PostInitializationCallback);

            // Do a simple filter
            var classDeclarations = initContext.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: IsTargetForGenerator,
                    transform: Transform);

            // Generate the source
            initContext.RegisterSourceOutput(classDeclarations, Execute);
        }

        public static bool IsTargetForGenerator(SyntaxNode SyntaxNode, CancellationToken cancellationToken)
        {
            // true if it's what we are looking for, in that case all clases in the specified namespace
            if (SyntaxNode is not ClassDeclarationSyntax classNode)
            {
                return false;
            }

            var temp = classNode.Parent;

            string? namespaceString = null;

            while (temp is not null)
            {
                if (temp is FileScopedNamespaceDeclarationSyntax fnsp)
                {
                    namespaceString = fnsp.Name.ToString();
                    break;
                }
                else if (temp is NamespaceDeclarationSyntax nsp)
                {
                    namespaceString = nsp.Name.ToString();
                    break;
                }

                temp = temp.Parent;
            }

            if (temp is null)
            {
                return false;
            }

            return namespaceString == NameSpace;
        }

        public static ClassDeclarationSyntax Transform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
        {
            return (ClassDeclarationSyntax)context.Node;
        }

        public static void Execute(SourceProductionContext context, ClassDeclarationSyntax classDeclarationSyntax)
        {
            var id = classDeclarationSyntax.Identifier.ToString();

            var source = $@"// <auto-generated />
namespace {NameSpace};
using {BaseModelNamespace};
public partial class {id} : BaseModel<{id}> {{ }}
";

            context.AddSource($"{NameSpace}{id}{GeneratorName}.g.cs", source);
        }

        public static void PostInitializationCallback(IncrementalGeneratorPostInitializationContext context)
        {
            // Unconditionally generated files
            context.AddSource("SampleText.g.cs", "// <auto-generated />");
        }
    }
}